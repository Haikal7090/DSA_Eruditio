# -*- coding: utf-8 -*-
"""Data  Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jxw6_xukKHA0a6GJJ_MdEasBjEgjY4tP

Import Dependecies
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, classification_report

"""Load Data"""

!pip install gdown
!gdown --fuzzy "https://drive.google.com/file/d/1BN8Jiypz-fCpCO797jldTfQldPIGOJTi/view?usp=sharing"
!gdown --fuzzy "https://drive.google.com/file/d/1sJUJMQA_2b50yvF4WEGsWvlUrADzVUJz/view?usp=sharing"

# Membaca file CSV

df = pd.read_csv('train.csv')
df_test = pd.read_csv('test.csv')

df.head()

df.shape

df.info()

df.isnull().sum()

# Mengecek dan mengganti nilai 0 menjadi NaN di setiap kolom
df = df.replace(0, np.nan)
df.isnull().sum()

# Menghitung jumlah baris duplikat berdasarkan semua kolom
jumlah_duplikat = df.duplicated().sum()
print(f"Jumlah baris duplikat berdasarkan semua kolom: {jumlah_duplikat}")

numerical_cols = [
    'electricity_consumption',
    'temperature_2m_max',
    'temperature_2m_min',
    'apparent_temperature_max',
    'apparent_temperature_min',
    'sunshine_duration',
    'daylight_duration',
    'wind_speed_10m_max',
    'wind_gusts_10m_max',
    'wind_direction_10m_dominant',
    'shortwave_radiation_sum',
    'et0_fao_evapotranspiration'
]

# Menghitung jumlah outlier untuk setiap kolom numerik berdasarkan cluster_id
outlier_summary = {}

for cluster in df['cluster_id'].unique():
    cluster_df = df[df['cluster_id'] == cluster]
    outlier_counts = {}
    for col in numerical_cols:
        Q1 = cluster_df[col].quantile(0.25)
        Q3 = cluster_df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        outlier_count = ((cluster_df[col] < lower_bound) | (cluster_df[col] > upper_bound)).sum()
        outlier_counts[col] = outlier_count
    outlier_summary[cluster] = outlier_counts

outlier_df = pd.DataFrame(outlier_summary)
display(outlier_df)

# prompt: •	Rasio Perbandingan: Rasio perbandingan konsumsi rata-rata antar cluster dapat dihitung dengan mengelompokkan data berdasarkan cluster_id dan menghitung rata-rata electricity_consumption. Rasio ini penting untuk perencanaan kapasitas regional.
# ________________________________________
# hitung rasio perbandingan

# Hitung rata-rata konsumsi listrik per cluster
average_consumption_per_cluster = df.groupby('cluster_id')['electricity_consumption'].mean().sort_values(ascending=False)

print("Rata-rata Konsumsi Listrik per Cluster:")
print(average_consumption_per_cluster)

# Hitung rasio perbandingan antara rata-rata konsumsi
# Jika ada lebih dari satu cluster, hitung rasio relatif terhadap cluster dengan konsumsi tertinggi
if len(average_consumption_per_cluster) > 1:
    cluster_highest_consumption = average_consumption_per_cluster.index[0]
    highest_consumption_value = average_consumption_per_cluster.iloc[0]

    consumption_ratios = average_consumption_per_cluster / highest_consumption_value

    print("\nRasio Konsumsi Listrik per Cluster (Relatif terhadap Cluster dengan Konsumsi Tertinggi):")
    print(consumption_ratios)
else:
    print("\nHanya ada satu cluster, tidak dapat menghitung rasio perbandingan.")

"""EXplanatory Data Analysis"""

# Grafik Univariate: Distribusi setiap fitur numerik untuk setiap cluster
for cluster in df['cluster_id'].unique():
    cluster_data = df[df['cluster_id'] == cluster]
    plt.figure(figsize=(18, 18))
    for i, col in enumerate(numerical_cols, 1):
        plt.subplot(4, 3, i)
        sns.histplot(cluster_data[col], kde=True)
        plt.title(f'Distribusi {col} (Cluster {cluster})')
    plt.tight_layout()
    plt.show()

# prompt: Buatkan aku grafik hubungan dari konsumsi listrik dengan suhu

# Grafik Bivariate: Hubungan antara konsumsi listrik dengan suhu
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='temperature_2m_max', y='electricity_consumption', alpha=0.5)
plt.title('Hubungan antara Konsumsi Listrik dan Suhu Maksimum')
plt.xlabel('Suhu Maksimum (°C)')
plt.ylabel('Konsumsi Listrik')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='temperature_2m_min', y='electricity_consumption', alpha=0.5)
plt.title('Hubungan antara Konsumsi Listrik dan Suhu Minimum')
plt.xlabel('Suhu Minimum (°C)')
plt.ylabel('Konsumsi Listrik')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='apparent_temperature_max', y='electricity_consumption', alpha=0.5)
plt.title('Hubungan antara Konsumsi Listrik dan Suhu Nyata Maksimum')
plt.xlabel('Suhu Nyata Maksimum (°C)')
plt.ylabel('Konsumsi Listrik')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='apparent_temperature_min', y='electricity_consumption', alpha=0.5)
plt.title('Hubungan antara Konsumsi Listrik dan Suhu Nyata Minimum')
plt.xlabel('Suhu Nyata Minimum (°C)')
plt.ylabel('Konsumsi Listrik')
plt.show()

import itertools

# Grafik Bivariate: Scatterplot untuk semua pasangan kolom numerik di setiap cluster
for cluster_id in df['cluster_id'].unique():
    cluster_data = df[df['cluster_id'] == cluster_id]
    for x_col, y_col in itertools.combinations(numerical_cols, 2):
        plt.figure(figsize=(7, 5))
        sns.scatterplot(
            data=cluster_data,
            x=x_col,
            y=y_col
        )
        plt.title(f'Scatterplot {x_col} vs {y_col} (Cluster {cluster_id})')
        plt.xlabel(x_col)
        plt.ylabel(y_col)
        plt.tight_layout()
        plt.show()

# Membuat heatmap korelasi fitur numerik untuk setiap cluster
for cluster_id in df['cluster_id'].unique():
    cluster_df = df[df['cluster_id'] == cluster_id]
    plt.figure(figsize=(10, 8))
    corr = cluster_df[numerical_cols].corr()
    sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
    plt.title(f'Heatmap Korelasi Fitur Numerik - {cluster_id}')
    plt.show()

# Membuat boxplot untuk setiap kolom numerik berdasarkan cluster
plt.figure(figsize=(20, 40))
for i, col in enumerate(numerical_cols, 1):
    plt.subplot(len(numerical_cols), 1, i)
    sns.boxplot(data=df, x='cluster_id', y=col)
    plt.title(f'Boxplot {col} berdasarkan Cluster')
    plt.xlabel('Cluster')
    plt.ylabel(col)
plt.tight_layout()
plt.show()

"""Data Cleaning"""

# Menghitung persentase missing values untuk setiap kolom di setiap cluster dan merapikan tampilan
missing_percent_per_cluster = (
    df.groupby('cluster_id')
      .apply(lambda g: g.isnull().mean() * 100)
      .round(2)
      .T  # Transpose agar cluster jadi kolom
)

display(missing_percent_per_cluster.style.format("{:.2f}%").set_caption("Persentase Missing Values per Kolom di Setiap Cluster"))

# Pastikan numerical_cols sudah terdefinisi, jika belum, definisikan di sini
numerical_cols = [
    'electricity_consumption',
    'temperature_2m_max',
    'temperature_2m_min',
    'apparent_temperature_max',
    'apparent_temperature_min',
    'sunshine_duration',
    'daylight_duration',
    'wind_speed_10m_max',
    'wind_gusts_10m_max',
    'wind_direction_10m_dominant',
    'shortwave_radiation_sum',
    'et0_fao_evapotranspiration'
]

# Menghapus outlier pada semua kolom numerik berdasarkan IQR untuk setiap cluster
def remove_outliers_all_cols_iqr_per_cluster(df, cols):
    cleaned = []
    for cluster in df['cluster_id'].unique():
        cluster_df = df[df['cluster_id'] == cluster]
        mask = pd.Series([True] * len(cluster_df), index=cluster_df.index)
        for col in cols:
            Q1 = cluster_df[col].quantile(0.25)
            Q3 = cluster_df[col].quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            mask &= (cluster_df[col] >= lower_bound) & (cluster_df[col] <= upper_bound)
        cleaned.append(cluster_df[mask])
    return pd.concat(cleaned, ignore_index=True)

df_no_outlier_all = remove_outliers_all_cols_iqr_per_cluster(df, numerical_cols)
df_no_outlier_all.shape

# Mengisi nilai kosong pada df_no_outlier_all menggunakan interpolasi linier
df_filled = df_no_outlier_all.interpolate(method='linear', limit_direction='both')

# Mengambil data outlier yang telah dihapus dari df
outliers = df[~df.index.isin(df_no_outlier_all.index)]

# Mengisi nilai kosong pada outlier menggunakan interpolasi linier
outliers_filled = outliers.interpolate(method='linear', limit_direction='both')

# Menggabungkan kembali data hasil interpolasi
final_df = pd.concat([df_filled, outliers_filled], ignore_index=True)

# Cek hasil
final_df.info()
final_df.isnull().sum()

# Grafik Univariate: Distribusi setiap fitur numerik untuk setiap cluster
for cluster in final_df['cluster_id'].unique():
    cluster_data = final_df[final_df['cluster_id'] == cluster]
    plt.figure(figsize=(18, 18))
    for i, col in enumerate(numerical_cols, 1):
        plt.subplot(4, 3, i)
        sns.histplot(cluster_data[col], kde=True)
        plt.title(f'Distribusi {col} (Cluster {cluster})')
    plt.tight_layout()
    plt.show()

# Grafik Bivariate: Scatterplot untuk semua pasangan kolom numerik di setiap cluster
for cluster_id in final_df['cluster_id'].unique():
    cluster_data = final_df[final_df['cluster_id'] == cluster_id]
    for x_col, y_col in itertools.combinations(numerical_cols, 2):
        plt.figure(figsize=(7, 5))
        sns.scatterplot(
            data=cluster_data,
            x=x_col,
            y=y_col
        )
        plt.title(f'Scatterplot {x_col} vs {y_col} (Cluster {cluster_id})')
        plt.xlabel(x_col)
        plt.ylabel(y_col)
        plt.tight_layout()
        plt.show()

# Membuat heatmap korelasi fitur numerik untuk setiap cluster
for cluster_id in final_df['cluster_id'].unique():
    cluster_df = final_df[final_df['cluster_id'] == cluster_id]
    plt.figure(figsize=(10, 8))
    corr = cluster_df[numerical_cols].corr()
    sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
    plt.title(f'Heatmap Korelasi Fitur Numerik - {cluster_id}')
    plt.show()

# Membuat boxplot untuk setiap kolom numerik berdasarkan cluster
plt.figure(figsize=(20, 40))
for i, col in enumerate(numerical_cols, 1):
    plt.subplot(len(numerical_cols), 1, i)
    sns.boxplot(data=final_df, x='cluster_id', y=col)
    plt.title(f'Boxplot {col} berdasarkan Cluster')
    plt.xlabel('Cluster')
    plt.ylabel(col)
plt.tight_layout()
plt.show()